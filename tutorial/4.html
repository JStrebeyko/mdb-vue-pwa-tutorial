<!--Section: Tutorial content-->
<section class="tutorial" id="adding-pwa">
  <h2 class="title mb-4">
    <strong>HTTPS & Service workers</strong>
  </h2>

  <p class="description">
    Let's talk about the last two requirements that we need to meet before our app becomes installable - having it
    served through <code>https</code> and do so accompanied by a <code>service worker</code>.</p>

  <div class="text-center mt-5"> <img class="img-fluid"
      src="https://mdbootstrap.com/wp-content/themes/mdbootstrap4/content/vue/tutorials/vue-pwa/4/banner.jpg"
      alt="Install baner"></div>


  <h4 class="mt-5"><strong>What is a service worker?</strong> </h4>

  <p class="description">A service worker is a type of web worker, an exciting concept which has opened modern browsers
    to the world of offline experiences. How? In short, it is a script that runs on a separate thread, independently
    from the website. Why is it such a game-changer?</p>

  <p class="description">During the first steps into the world of JavaScript, you probably saw how infinite
    loops in the code affected the UI - namely, the JS-run functionalities became unreposnsive. They blocked "the main
    thread" and then the interface froze.</p>

  <p>It's all because JavaScript is a single threaded language. It means it has one call stack and one memory heap,
    executing code in order. When things go south (like loops iterating endlessly or synchronous requests taking too
    long), the whole thing topples, rendering the UI unresponsive.</p>

  <p>The idea of a web worker is exciting, because it has its own thread, and so it can be performing heavy-lifting
    tasks, which otherwise would reduce your website's performance, in the background. What's more, according to <a
      href="https://www.w3.org/TR/workers/" target="_blank">the spec</a>, workers are able to be working for a long time
    after the window responsible for its spawning has been closed (although it can take no more new tasks).</p>

  <p>"Ok," someone could say, "so a service worker is like some additional computing power, but we get it anyhow, as the
    hardware tech progresses." Workers would be a considerable boost with no clear direction, if it wasn't for one
    architecural implication: they sit between the browser and the network and act as proxy servers. It means
    that they not only get their own thread for computation, but also they do so while in between the client and the
    server. They can intercept requests made by the website and <strong>redirect them to the cache</strong>. Imagine,
    there is an outgoing request for constent and all the response get saved in the browser memory along the way,
    dropping the need for requesting it again. Next time we are trying to access some of it, <strong>no internet
      connection is needed</strong>.</p>

  <p>This is where the service worker shines - as a vehicle for caching and data management. It can provide us with
    content access and features like push notifications, even in case the internet connection was lost.</p>

  <p>This kind of power comes with a price, though. This is a new technology, so it's only supported by modern browsers.
    Also, as service workers could be easily misused, they use is restricted to running across HTTPS for security
    reasons. Although during development we will be able to use a service worker through <code>localhost</code>, to
    deploy it on a site, a <strong>HTTPS setup on your server</strong> will be needed.</p>

  <p>Web workers are a huge topic by themselves and here I'll touch upon their bare, code-based essentials in the PWA
    context - namely, how to register one, what it usually consists of and some tips on development. There are some
    extensive <a href="https://developers.google.com/web/fundamentals/primers/service-workers/">materials</a> regarding
    the subject prepared by the industry leaders - be sure to check them for a deep dive.</p>

  <h4 class="mt-5"><strong>The File</strong> </h4>

  <p>Service Worker is JavaScript code living in a different thread than the browser's main one, where the UI and and
    rest of the JS resides. In that way, it is very special - for browsers to be able to adequately utilize it, it must
    be properly registered (more on that below) and defined in a separate file. From there it does not have direct
    access to reglar Web APIs, like the <code>window</code> global object.</p>

  <p>What the worker does, in practive, is reacting to certain events - this is why the file itself consists mainly of
    callbacks. To refer to itself from within the worker to add event listeners, the API exposes a <code>self</code>
    variable, making it a little bit more reliable for beginners than the regular, dynamically bound <code>this</code>.
  </p>

  <mdbsnippet>
    <code data-lang="js" data-name="./service-worker.js">
      const cacheVersion = 'v1';

      self.addEventListener('install', function (event) {
      self.skipWaiting(); // We do it for our worker not to wait until the previous one expires

      event.waitUntil(
      caches.open(cacheVersion).then(function (cache) {
      return cache.addAll([
      './index.html'
      ]);
      })
      );
      });

      self.addEventListener('fetch', function (event) {
      event.respondWith(caches.match(event.request).then(function (response) {
      // caches.match() always resolves
      // but in case of success response will have value
      if (response !== undefined) {
      return response;
      } else {
      return fetch(event.request).then(function (response) {
      // response may be used only once
      // we need to save clone to put one copy in cache
      // and serve second one
      let responseClone = response.clone();

      caches.open(cacheVersion).then(function (cache) {
      cache.put(event.request, responseClone);
      });
      return response;
      }).catch(function () {
      return console.log('no cache response!');
      });
      }
      }));
      });
    </code>
  </mdbsnippet>

  <p>As you can see, the worker above listens for two events.</p>

  <p>The <code>install</code> event provides an opportunity to define the caching policy. First, we call
    <code>self.skipWaiting();</code> so that our Worker gets to work instantly. Then, it opens a perticular cache (named
    <code>v1</code>) and uses the <code>cache.addAll()</code> method to add a list of specific files there. As of now,
    we only cache <code>./index.html</code>.</p>

  <p>What we have stored, we ultimately want to retrieve. To define the fashion in which it happens, <code>fetch</code>
    event callback and response's <code>.respondWith()</code> method are used. In case there is an already stored
    resource for a specific request (<code>caches.match(event.request)</code>) and it's not undefined, we retrieve it
    and pass as the return value of the <code>fetch</code>. In case it is in fact undefined (so, not stored), we do a
    request to the web for it, but immidiately it gets back, we clone it, so we can both store it in the cache and serve
    it as a response.</p>

  <p>With this worker script we cache what we need, and once the client gets back to us on a subsequent visit, the
    resources it requested for in the past go straight from the cache -- and in case we get asked for something we do
    not have stored yet, we fetch for it, to serve it and store for later.</p>

  <h4 class="mt-5"><strong>The Registration</strong> </h4>

  <p>For the above file to be considered a service worker and not a regular, "same-thread" JavaScript file, it must be
    registered as such. We could do it wherever (including a rude <code>script</code> tag within HTML), but we'll do it
    in the (webpack's & JavaScripts') entry point, namely the <code>src/main.js</code> file, tucked underneath the root
    Vue insance.</p>

  <mdbsnippet>
    <code data-lang="js" data-name="./src/main.js">
      if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/service-worker.js').then(() => {
      console.log('Service Worker registered!');
      });
      } else {
      console.log('Service Worker not supported :(');
      }
    </code>
  </mdbsnippet>

  <p>In webdev practive, it would be worthwhile ensuring that what we do above, which still takes place on the main
    thread, is not blocking us from rendering what we want to show. We could achieve it by simply wrapping the
    registration into the the window's <code>load</code> event callback. Luckily, though, the webpack-transpiled
    code is being injected at the end of the <code>&lt;body&gt;</code> tag, which suffices for a guarantee in our use
    case.</p>

  <h4 class="mt-5"><strong>Workflow twaeks</strong> </h4>

  <p>With the <code>register</code> and <code>install</code> life-cycle steps accounted for, we have all the main
    indridients for a successful service worker implementation. We might find an issue in the console regarding the
    files MIME type, though. Why?</p>

  <p>It's because our webpack dev server and production build configs don't expect a JavaScirpt file being served from
    the root directory while not being processed by the bundler. Moving <code>./service-worker.js</code> to the
    <code>/static</code> directory (where our manifest.json already resides) seems like a good way to sneak it
    in; unfortunately, it wouldn't help our case. Again, why?</p>

  <p>Considering how <strong>powerful</strong> a feature the service worker is, there are security measures undertaken to protect from
    misuse. One of them is the the service worker's <code>scope</code> - even though we can declare it explicitly from
    the options object passed as the second argument in <code>navigator.serviceWorker.register()</code> function, it can
    never go "up" from where the service worker is defined. It means that you can have define custom workers for
    different places of your projects, but also that the worker in <code>/static</code> directory could never reach
    files outside of it, like our <code>index.html</code>.</p>

  We need to slightly alter our <code>dev</code> and <code>prod</code> config files in the <code>/build</code>
  directory. In both of them we are utilizing the <code>CopyWebpackPlugin</code> to move our files around. Let's mention
  our service worker there - that way it will available both for the dev server and also in the <code>/dist</code>
  directory once we build.

  <mdbsnippet>
    <code data-lang="js" data-name="./build/webpack.dev.config.js">
      new CopyWebpackPlugin([
      {
      from: path.resolve(__dirname, '../static'),
      to: config.dev.assetsSubDirectory,
      ignore: ['.*']
      },
      {
      from: path.resolve(__dirname, '../service-worker.js'),
      to: './service-worker.js',
      }
      ])
    </code>
    <code data-lang="js" data-name="./build/webpack.prod.config.js">
      new CopyWebpackPlugin([
      {
      from: path.resolve(__dirname, '../static'),
      to: config.build.assetsSubDirectory,
      ignore: ['.*']
      },
      {
      from: path.resolve(__dirname, '../service-worker.js'),
      to: './service-worker.js',
      }
      ])
    </code>
  </mdbsnippet>

  <p>And voilà! Now we are declaratively giving access to the file to the webpack dev server, while also having the
    worker script copied to the <code>/dist</code> when we build.</p>

  <h4 class="mt-5"><strong>Default scaffolding with Vue-CLI</strong></h4>

  <p>Our purpose here was to do everything by ourselves for learning purposes, but in everyday developer work we could
    make use of some already existing tools for the job. For new projects usually we wouldn't need the fine-grained
    control provided with a custom webpack config, and could go for a ready-made, scaffolding solution of <a
      href="https://cli.vuejs.org/guide/"><code>Vue-CLI</code></a>. The command line solution provides us with less "to
    the metal" configuration options, as the bundler's roughness is hidden beneath the <code>vue-cli-service</code>
    scripts' abstraction, while adding some helpful extras - a ready-made project strucutre and some great development
    features, including a great PWA support plugin.</p>

  <p>A project created this way would have a <code>src/registerServiceWorker.js</code> script included out-of-the-box.
    Under the hood it would utilize <code><a
        href="https://www.npmjs.com/package/register-service-worker">register-service-worker</a></code>, a module
    created by Evan You, Vue author, that simplifies worker registration and provides hooks to customize worker's
    reaction to some of the most common events, like caching, finding an update or going offline.</p>

  <h4 class="mt-5"><strong>Serving over HTTPS</strong> </h4>

  <p>We have already deployed our applications to Firebase Hosting, so we don't need to worry about HTTPS - our
    domain is already HTTPS-certified. So let's update our hosted app: </p>

  <mdbsnippet>
    <code data-lang="js" data-name="CLI">
      yarn deploy
    </code>
  </mdbsnippet>

  <p>Now, let's test it. If you open your website, after a few seconds you should see an install banner. Install the
    app.</p>

  <div class="text-center"> <img class="img-fluid"
      src="https://mdbootstrap.com/wp-content/themes/mdbootstrap4/content/vue/tutorials/vue-pwa/4/save.jpg"
      alt="Install baner"></div>

  <p>Do you see this? Our nice app icon is staring at us from the smartphone's home screen!</p>

  <div class="text-center"> <img class="img-fluid"
      src="https://mdbootstrap.com/wp-content/themes/mdbootstrap4/content/react/tutorials/react-pwa/4/homescreen.jpg"
      alt="Homescren View"><br></div>

  <p>In the next lesson, we will make our application work offline </p>

  <p class="description">Something doesn't work for you? Then check the code for this lesson in our <a
      href="https://github.com/mdbootstrap/React-Tutorial-PWA/archive/master.zip">repository</a></p>
</section>
<!--Section: Tutorial content