<!--Section: Tutorial content-->
<section class="tutorial" id="adding-pwa">
  <h2 class="title mb-4">
    <strong>HTTPS & Service workers</strong>
  </h2>

  <p class="description">
    Let's talk about the last two requirements that we need to meet before our app becomes installable - having it
    served through <code>https</code> and do so accompanied by a <code>service worker</code>.</p>

  <div class="text-center mt-5"> <img class="img-fluid"
      src="https://mdbootstrap.com/wp-content/themes/mdbootstrap4/content/vue/tutorials/vue-pwa/4/banner.jpg"
      alt="Install baner"></div>


  <h4 class="mt-5"><strong>What is a service worker?</strong> </h4>

  <p class="description">A service worker is a type of web worker, an exciting concept which has opened modern browsers
    to the world of offline experiences. How? In short, it is a script that runs on a separate thread, independently
    from the website. Why is it such a game-changer?</p>

  <p class="description">When you took your first steps into the world of JavaScript, you probably saw how infinite
    loops in your code affected the UI - namely, the JS-run functionalities became unreposnsive. They blocked "the main
    thread" and then the interface froze.</p>

  <p>It's because JavaScript is a single threaded language, which means it has one call stack and one memory heap. As
    such, it executes code in order and when things go south (like loops iterating endlessly or synchronous requests
    taking too long), the whole thing topples, rendering the UI unresponsive.</p>

  <p>The idea of a web worker is exciting, because it has its own thread, and so it can be performing heavy-lifting
    tasks in the background, which otherwise would reduce your website's performance. What's more, according to <a
      href="https://www.w3.org/TR/workers/" target="_blank">the spec</a>, a service worker may be even be working for
    long after the window responsible for its spawning has been closed (although it can take no more new tasks).</p>

  <p>"Ok," someone could say, "so a service worker is like some additional computing power, what about it?" Workers
    would be a considerable boost with no clear direction, if it wasn't for one architecural implication, namely - they
    sit between the browser and the network and act as proxy servers. It means that the not only reside on a sperate
    thread, but also in between the client and the server - they can intercept requests made by the
    website and <strong>redirect them to the cache</strong>. Imagine, there is an outgoing request for constent, all of
    which gets saved in the browser memory. It means that next time we are trying to access some of it, <strong>no
      internet connection is needed</strong>.</p>

  <p>This is where the service worker shines - as vehicles for caching and data management. They can provide us with
    content access and features like push notifications, even in case the internet connection was lost.</p>

  <p>This kind of power comes with a price, though. This is a new technology, so it's only supported by modern browsers. Also, as service workers could be easily misused, they use is restricted to running across HTTPS. Although during development you'll be able to use a service worker through <code>localhost</code>, to deploy it on a site you'll need to have <strong>HTTPS setup on your server, for security reasons</strong>.</p>
 
    <p>Web workers are a huge topic by themselves and here I'll touch upon the bare, code-based essentials of service worker in the PWA context - the way to register one, what it usually consists of and some tips on development. If you'll find yourself hungry for more after we're done here ( and the tech definitely deserves it), I suggest going over some industry leaders' <a href="https://developers.google.com/web/fundamentals/primers/service-workers/">materials</a>.</p>

    <h4 class="mt-5"><strong>The File</strong> </h4>

    <p>Service Worker is JavaScript code living in a different thread than the browser's main one, where the UI and and rest of the JS resides. In that way, it is very special - for browsers to be able to adequately utilize it, it must be properly registered (more on that below) and defined in a separate file. From there it does not have direct access to reglar Web API like the <code>window</code> global object, for example.</p>

    <p>What the worker does is reacting to certain events, and so the file consists of callbacks. To refer to itself within it to add an event listener, the API exposes a <code>self</code> variable, making it a little bit more reliable for beginners than the regular, dynamically bound <code>this</code>.</p>

    <mdbsnippet>
      <code data-lang="js" data-name="./service-worker.js">
        const cacheVersion = 'v1';

        self.addEventListener('install', function (event) {
          self.skipWaiting();
        
          event.waitUntil(
            caches.open(cacheVersion).then(function (cache) {
              return cache.addAll([
                './index.html'
              ]);
            })
          );
        });
        
        self.addEventListener('fetch', function (event) {
          event.respondWith(caches.match(event.request).then(function (response) {
            console.log(event)
            // caches.match() always resolves
            // but in case of success response will have value
            if (response !== undefined) {
              return response;
            } else {
              return fetch(event.request).then(function (response) {
                // response may be used only once
                // we need to save clone to put one copy in cache
                // and serve second one
                let responseClone = response.clone();
        
                caches.open(cacheVersion).then(function (cache) {
                  cache.put(event.request, responseClone);
                });
                return response;
              }).catch(function () {
                return console.log('no cache response!');
              });
            }
          }));
        });
      </code>
    </mdbsnippet>

    <p>As you can see, the worker above listens for two events.</p>

    <p>The <code>install</code> event provides an opportunity to define the caching policy. First, we call <code>self.skipWaiting();</code> so that our Worker gets to work instantly. Then, it opens a perticular cache (named <code>v1</code>) and uses the <code>cache.addAll()</code> method to add a list of specific files there. As of now, we only cache <code>./index.html</code></p>

    <p>What we have stored we want to ultiately retrieve. To define the fashion in which it happens, <code>fetch</code> event callback and response's <code>.respondWith()</code> method are used. In case there is an already stored resource for a specific request (<code>caches.match(event.request)</code>) and it's not undefined, we retrieve it and pass as the return value of the <code>fetch</code>. In case it is in fact undefined (so, not stored), we do a request to the web for it, but immidiately it gets back, we clone it, so we can both store it in the cache and serve it as a response.</p>

    <p>With this worker script we cache what we need, and once the client's on a subsequent visit, the resources it requests go straight from the cache -- and if we do not have them stored yet, we immidiately do.</p>

    <h4 class="mt-5"><strong>The Registration</strong> </h4>

    <p>For the above file to be considered a service worker and not a regular, "same-thread" JavaScript file, it must be registered as such. We could do it wherever (including a rude <code>script</code> tag within HTML), but we'll do it in the (webpack's & JavaScripts') entry point, namely the <code>src/main.js</code> file, tucked underneath the root Vue insance.</p>

    <mdbsnippet>
      <code data-lang="js" data-name="./service-worker.js">
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('/service-worker.js').then(() => {
            console.log('Service Worker registered!');
          });
        } else {
          console.log('Service Worker not supported :(');
        }
      </code>
    </mdbsnippet>

    <p>It would be worth to make sure that the registration, which still takes place on the main thread, is not blocking whatever we want to render. We could achieve it by simply wrapping it inside the window's <code>load</code> event callback. In this case, though, the webpack-transpiled code is being injected at the end of the <code>&lt;body&gt;</code>, which suffices in our case.</p>

  <!-- TODO: Double-check the location - it should not be /dist -->

  <h4 class="mt-5"><strong>Workflow twaeks</strong> </h4>

  <p>We have all the main indridients for a successful service worker with its <code>register</code> and <code>install</code> life-cycle steps accounted for! You might find an issue in the console regarding the files MIME file, though.</p>
  
  <p>It originates from the fact that our webpack dev server and production build configs don't expect a JavaScirpt file being served from the directory root and not being processed by the bundler. Moving <code>service-worker.js</code> to the <code>/static</code> directory (where our manifest.json already resides) seems like a good way to sneak it in; unfortunately, it wouldn't help our case.</p>
  
  <p>Considering how powerful a feature the service worker is, there are security measures undertaken to protect from misuse. One of them is the the service worker's <code>scope</code> - even though we can declare it explicitly from the options object passed as the second argument in <code>navigator.serviceWorker.register()</code> function, it can never go "up" from where the service worker is defined. It means that you can have define custom workers for different places of your projects, but also that the worker in <code>/static</code> directory could never reach files outside of it, like our <code>index.html</code>.</p>

  We need to slightly alter our <code>dev</code> and <code>prod</code> config files in the <code>/build</code> directory. In both of them we are utilizing the <code>CopyWebpackPlugin</code> to move our files around. Let's mention our service worker there - that way it will available both for the dev server and also in the <code>/dist</code> directory once we build.

  <mdbsnippet>
    <code data-lang="js" data-name="./build/webpack.dev.config.js">
      new CopyWebpackPlugin([
      {
        from: path.resolve(__dirname, '../static'),
        to: config.dev.assetsSubDirectory,
        ignore: ['.*']
      },
      {
        from: path.resolve(__dirname, '../service-worker.js'),
        to: './service-worker.js',
      }
    ])
    </code>
    <code data-lang="js" data-name="./build/webpack.prod.config.js">
      new CopyWebpackPlugin([
      {
        from: path.resolve(__dirname, '../static'),
        to: config.build.assetsSubDirectory,
        ignore: ['.*']
      },
      {
        from: path.resolve(__dirname, '../service-worker.js'),
        to: './service-worker.js',
      }
    ])
    </code>
  </mdbsnippet>

  <p>And voilà! Now we are declaratively giving access to the file to the webpack dev server, while also having the worker script copied to the <code>/dist</code> when we build.</p>

  <h4 class="mt-5"><strong>Default scaffolding with Vue-CLI</strong></h4>

  <p>Our purpose here was to do everything by ourselves for learning purposes, but in everyday developer work we could make use of some already existing tools for the job. For new projects usually we wouldn't need the fine-grained control provided with a custom webpack config, and could go for a ready-made, scaffolding solution of <a href="https://cli.vuejs.org/guide/"><code>Vue-CLI</code></a>. The command line solution provides us with less "to the metal" configuration options, as the bundler's roughness is hidden beneath the <code>vue-cli-service</code> scripts' abstraction, while adding some helpful extras - a ready-made project strucutre and some great development features, including a great PWA support plugin.</p>
  
  <p>A project created this way would have a <code>src/registerServiceWorker.js</code> script included out-of-the-box. Under the hood it would utilize <code><a
        href="https://www.npmjs.com/package/register-service-worker">register-service-worker</a></code>, a module
    created by Evan You, Vue author, that simplifies worker registration and provides hooks to customize worker's
    reaction to some of the most common events, like caching, finding an update or going offline.</p>

  <h4 class="mt-5"><strong>Serving over HTTPS</strong> </h4>

  <p>We have already deployed our applications to Firebase Hosting, so we don't need to worry about HTTPS - our
    domain is already HTTPS-certified. So let's update our hosted app: </p>

  <mdbsnippet>
    <code data-lang="js" data-name="CLI">
      yarn deploy
    </code>
  </mdbsnippet>

  <p>Now, let's test it. If you open your website, after a few seconds you should see an install banner. Install the
    app.</p>

  <div class="text-center"> <img class="img-fluid"
      src="https://mdbootstrap.com/wp-content/themes/mdbootstrap4/content/vue/tutorials/vue-pwa/4/save.jpg"
      alt="Install baner"></div>

  <p>Do you see this? Our nice app icon is staring at us from the smartphone's home screen!</p>

  <div class="text-center"> <img class="img-fluid"
      src="https://mdbootstrap.com/wp-content/themes/mdbootstrap4/content/react/tutorials/react-pwa/4/homescreen.jpg"
      alt="Homescren View"><br></div>

  <p>In the next lesson, we will make our application work offline </p>

  <p class="description">Something doesn't work for you? Then check the code for this lesson in our <a
      href="https://github.com/mdbootstrap/React-Tutorial-PWA/archive/master.zip">repository</a></p>
</section>
<!--Section: Tutorial content